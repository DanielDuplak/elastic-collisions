void check_circle_collisions(Circle* circles)
{
    for(int i = 0; i < OBJECT_COUNT; i++)
    {
        for(int j = i+1; j < OBJECT_COUNT; j++)
        {
            float distance = std::sqrt((std::pow(circles[i].position.x - circles[j].position.x, 2)) +
                                       (std::pow(circles[i].position.y - circles[j].position.y, 2)));

            if(distance > (circles[i].shape.getRadius() + circles[j].shape.getRadius()))
            {
                continue;
            }

            Vector2D line_of_impact_vector = vector_sub(circles[j].position, circles[i].position);
            Vector2D velocity_difference_vector = vector_sub(circles[j].velocity, circles[i].velocity);
            
            float distance_squared = distance * distance;

            float velocity_impact_dot = dot_product(velocity_difference_vector, line_of_impact_vector);
            float mass_ratio = (2 * circles[j].mass) / (circles[i].mass + circles[j].mass);

            Vector2D new_velocity_i = vector_sum(
                circles[i].velocity,
                vector_scalar_product(
                    line_of_impact_vector,
                    mass_ratio * velocity_impact_dot / distance_squared
                ));

            line_of_impact_vector = vector_sub(circles[i].position, circles[j].position);
            velocity_difference_vector = vector_sub(circles[i].velocity, circles[j].velocity);

            velocity_impact_dot = dot_product(velocity_difference_vector, line_of_impact_vector);
            mass_ratio = (2 * circles[i].mass) / (circles[i].mass + circles[j].mass);

            Vector2D new_velocity_j = vector_sum(
                circles[j].velocity,
                vector_scalar_product(
                    line_of_impact_vector,
                    mass_ratio * velocity_impact_dot / distance_squared
                ));

            float overlap = distance - (circles[i].shape.getRadius() + circles[j].shape.getRadius());
            Vector2D direction = vector_set_magnitude(line_of_impact_vector, overlap * 0.5f);
            circles[i].position = vector_sub(circles[i].position, direction);
            circles[j].position = vector_sum(circles[j].position, direction);

            circles[i].velocity = new_velocity_i;
            circles[j].velocity = new_velocity_j;
        }
    }
}


void update_circles(Circle* circles, float delta_time, const sf::RenderWindow& window)
{
    for (int i = 0; i < OBJECT_COUNT; i++)
    {
        circles[i].velocity.x += circles[i].acceleration.x * delta_time;
        circles[i].velocity.y += circles[i].acceleration.y * delta_time;

        circles[i].position.x += circles[i].velocity.x * delta_time;
        circles[i].position.y += circles[i].velocity.y * delta_time;

        float radius = circles[i].shape.getRadius();

        if (circles[i].position.x - radius <= 0.0f)
        {
            circles[i].position.x = radius;
            circles[i].velocity.x *= -1;
        }
        else if(circles[i].position.x + radius >= window.getSize().x)
        {
            circles[i].position.x = window.getSize().x - radius;
            circles[i].velocity.x *= -1;
        }

        if (circles[i].position.y - radius <= 0.0f)
        {
            circles[i].position.y = radius;
            circles[i].velocity.y *= -1;
        }
        else if(circles[i].position.y + radius >= window.getSize().y)
        {
            circles[i].position.y = window.getSize().y - radius;
            circles[i].velocity.y *= -1;
        }

        circles[i].shape.setPosition(circles[i].position.x - radius, circles[i].position.y - radius);
    }
}